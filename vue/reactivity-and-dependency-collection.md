# 响应式原理和依赖收集

## 响应式原理：

-   Vue2 使用了 Object.defineProperty 来劫持组件中数据对象的属性。当这些属性被访问或修改时，Vue 能够检测到这些变化。
-   Vue3 使用 Proxy 来监听变化

## 依赖收集步骤：

-   观察者 `Observer` 类
    -   构造函数：在构造函数中触发被劫持数据的 `get` ，方便将其添加到 `Subject` 实例中
        -   观察者创建应该在劫持数据之后，否则创建的时候还没有 `get`
    -   更新函数（这边主要用来更新视图）
-   被观察者 `Subject` 类
    -   存储观察者们
    -   通知所有观察者更新（当数据变化的时候通知所有观察者）
-   通过 `Object.defineProperty` 劫持数据
    -   创建一个 `Subject` 实例
    -   `get` : 触发 `Subject` 实例添加观察者
    -   `set` : 触发 `Subject` 实例通知所有观察者

1. 数据劫持：通过 `Object.defineProperty` 对响应式数据进行劫持，在获取（`get`）和设置（`set`）属性值时触发相应的操作。
2. 创建依赖对象： 在组件初始化时，Vue 创建一个**依赖对象**（`Subject`），用于存储所有依赖于响应式属性的观察者（通常是组件的渲染函数）。
3. 依赖收集（ `get` 触发）：当读取响应式数据时，会将当前的 `Observer` （观察者）添加到依赖列表中。(在`Observer`的构造函数触发被劫持数据的 `get` )
4. 派发更新（ `set` 触发）：当响应式数据发生变化时，会遍历依赖列表，通知相关的 `Observer` 进行更新操作。(这些更新应该是在虚拟 DOM 的操作，会被放入异步更新队列中最后一起做 Diff)

## 依赖收集与异步更新队列的关系

-   当响应式数据发生变化时，Vue 会触发 `setter`，通知所有依赖于该数据的组件。
-   这些组件的更新请求会被放入异步更新队列中，而不是立即执行。
-   在当前事件循环的下一个“tick”中，Vue 会从队列中取出更新请求，并执行组件的渲染函数，更新 DOM。

## 简单实现

[Demo](/code/vue/reactivity-and-dependency-collection/index.html)

## Proxy vs Object.defineProperty()

### Object.defineProperty() 的优缺点

#### 优点

1. 兼容性比较好

#### 缺点

1. **性能** ： 对于复杂的对象需要深度监听，递归到底，一次性计算量大
2. **操作属性** ： 无法监听新增属性/删除属性（Vue.set Vue.delete）
3. **数组** ： 无法监听数组，需特殊处理

### Proxy 的优缺点

#### 优点

1. **操作属性** ： 监听内容更加全面，不只是对象的属性，对对象的操作都能监听（新增、删除属性等）
2. **支持数组**
3. **性能更好** （不用递归来实现深层次响应）
4. 可以直接操作对象

#### 缺点

1. Proxy 是 ES6 新增的内容，而且无法使用 Polyfill

> babel 无法转化 Proxy 到 ES5，现在没有完全兼容的 Polyfill，即使用了 Polyfill 也不能保证在所有地方完全响应。

## Vue 数组更新检测

1. 对会改变数组本身的方法进行处理，可以支持响应式
2. 可以直接整个替换成新数组，vue 有对其进行处理，并且十分高效

#### 变更方法

Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：

-   push()
-   pop()
-   shift()
-   unshift()
-   splice()
-   sort()
-   reverse()

你可以打开控制台，然后对前面例子的 items 数组尝试调用变更方法。比如 `example1.items.push({ message: 'Baz' })`。

#### 替换数组

变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组：

```js
example1.items = example1.items.filter(function (item) {
    return item.message.match(/Foo/)
})
```

你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。

## Vue 深层次响应式

Vue 多层嵌套递归监听，也就是说如果对应的 key 是对象的话，那么就对其进行同样的数据劫持，这样一层一层下去。
