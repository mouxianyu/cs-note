# 虚拟 DOM 和 Diff 算法

## 虚拟 DOM

虚拟 DOM 是真实 DOM 的一个轻量级、JavaScript 对象表示。它是一个树状结构，与真实 DOM 树结构对应，但只存在于内存中，不直接操作浏览器的 DOM。

### 工作原理

1. **创建虚拟 DOM 树**: 当应用初始化时，框架会根据组件的状态创建一个虚拟 DOM 树，这个树是真实 DOM 的一个副本，但**只存在于内存中**。
2. **状态更新**: 当应用的状态发生变化时，框架会触发重新渲染。这通常通过调用组件的 `render` 方法或类似的机制来完成。
3. **生成新的虚拟 DOM 树**: 状态更新后，框架会使用新的状态生成一个新的虚拟 DOM 树。
4. **差异比较（Diffing）**: 框架会使用差异算法比较新旧两个虚拟 DOM 树，找出它们之间的差异。这个过程称为“Diffing”或“Reconciliation”。
5. **生成补丁（Patches）**: 差异算法会生成一个补丁列表，这些补丁描述了如何将旧的虚拟 DOM 树更新为新的虚拟 DOM 树。
6. **应用补丁到真实 DOM**: 框架会将这些补丁应用到真实 DOM 上，只更新那些实际发生变化的部分。这一步是通过直接操作 DOM 来完成的，但它只影响需要更新的部分，而不是整个 DOM 树。
7. **优化性能**: 通过这种方式，虚拟 DOM 减少了不必要的 DOM 操作，因为只有实际发生变化的部分才会被更新到真实 DOM。这可以显著提高性能，尤其是在大型应用中。
8. **批量更新**: 框架通常会批量处理多个状态更新，以减少重渲染的次数和性能损耗。
9. **递归更新**: 虚拟 DOM 的更新是递归的，从根节点开始，逐层向下，直到叶子节点。这确保了只有实际受到影响的部分会被更新。
10. **事件处理**: 虚拟 DOM 树中的元素可以包含事件处理器，当事件发生时，这些处理器会被附加到真实 DOM 元素上。

### 优点

1. **🏷️ 性能提升**: 虚拟 DOM 通过减少直接对真实 DOM 的操作来提高应用性能。因为它只更新变化的部分，而不是整个页面。
2. **🏷️ 跨浏览器兼容性**: 虚拟 DOM 抽象了浏览器的 DOM 操作，使得开发者可以编写一次代码，无需担心不同浏览器之间的差异。
3. **🏷️ 开发效率**: 虚拟 DOM 简化了 DOM 操作，开发者可以用声明式的方式来描述 UI，而不必编写繁琐的 DOM 操作代码。
4. **🏷️ 易于维护**: 由于 UI 的更新逻辑与状态管理分离，代码更加清晰，易于维护和扩展。
5. **同构渲染（Isomorphic Rendering）**: 虚拟 DOM 支持在服务器端进行首次渲染，这可以加快首屏加载速度，改善 SEO。
6. **🏷️ 批量更新**: 虚拟 DOM 允许框架批量处理多个状态更新，**减少重渲染的次数**，从而提高性能。
7. **可预测性**: 由于 UI 的更新是基于状态的，开发者可以更容易地预测 UI 的变化。
8. **组件化**: 虚拟 DOM 与组件化开发模式相结合，使得开发者可以构建可复用的组件，提高代码的复用性。
9. **状态管理**: 虚拟 DOM 使得状态管理更加集中和一致，尤其是在复杂的应用中。
10. **动画和过渡效果**: 虚拟 DOM 可以更容易地实现复杂的动画和过渡效果，因为它可以精确控制 DOM 的更新。
11. **工具和生态系统**: 虚拟 DOM 相关的框架通常拥有丰富的工具和生态系统支持，如开发者工具、调试器、性能分析工具等。
12. **源码映射**: 在构建过程中，虚拟 DOM 可以保持源码映射，使得在生产环境中调试代码更加容易。
13. **错误边界**: 某些框架（如 React）提供了错误边界（Error Boundaries）的概念，可以在组件树中的某个位置捕获 JavaScript 错误，隔离错误组件，避免整个应用崩溃。

### 缺点

1. **🏷️ 内存消耗**: 虚拟 DOM 需要额外的内存来存储整个 DOM 树的 JavaScript 对象副本。对于大型应用，这可能会导致显著的内存使用增加。
2. **🏷️ 初次加载时间**: 虚拟 DOM 的渲染流程（创建虚拟 DOM 树、Diffing 算法、应用补丁到真实 DOM）可能会使应用的初次加载时间比直接操作 DOM 的方法稍长。
3. **性能瓶颈**: 如果不正确使用，虚拟 DOM 可能会引入性能瓶颈。例如，如果组件的 `shouldComponentUpdate` 生命周期方法没有正确实现，可能会导致不必要的重新渲染。
4. **学习曲线**: 对于不熟悉虚拟 DOM 或相关框架（如 React）的开发者来说，理解其工作原理和最佳实践可能需要一定的学习时间。
5. **调试难度**: 虚拟 DOM 可能会使调试变得更加困难，因为开发者需要理解虚拟 DOM 树和真实 DOM 树之间的关系，以及它们是如何映射的。
6. **🏷️ 过度优化**: 对于小型或简单的应用，虚拟 DOM 可能是一种过度优化。在这些情况下，直接操作 DOM 可能更简单、更直接。
7. **🏷️ 依赖特定框架**: 使用虚拟 DOM 通常意味着依赖特定的前端框架，这可能会限制开发者在项目中的灵活性和选择。
8. **DOM 操作的限制**: 虚拟 DOM 抽象了 DOM 操作，这可能会导致一些直接操作 DOM 的技巧和优化变得不适用或更难以实现。
9. **框架限制**: 虚拟 DOM 的实现和优化可能依赖于特定框架的内部机制，这可能会限制开发者对渲染过程的控制。
10. **状态管理复杂性**: 在一些复杂的应用中，状态管理可能变得更加复杂，尤其是在多个组件共享状态时。

## Diff 算法

**Diff 算法**（也称为差异比较算法或协调算法）是一种用于确定新旧虚拟 DOM 树之间差异的方法。这个算法的目的是找出哪些部分的 DOM 需要更新，以减少不必要的 DOM 操作，从而提高性能。

### 算法步骤

1. **比较同层级节点**: 从树的顶部开始，逐层向下比较同层级的节点。
2. **元素复用**: 如果新旧节点类型和 key 相同，框架会复用现有的 DOM 元素，而不是重新创建。
3. **列表比较**: 对于列表（数组），Diff 算法会尝试通过 key 来识别元素，以确定哪些元素是新添加的、被删除的或被移动的。
4. **最小化 DOM 操作**: 算法会生成一个最小的操作序列，以更新 DOM，包括添加、删除和移动 DOM 元素。
5. **批量更新**: 算法会将多个更新操作合并为单个重绘或重排，以减少性能损耗。

### 性能优化

-   **避免不必要的 DOM 操作**: 通过精确识别哪些部分需要更新，Diff 算法减少了对 DOM 的操作次数。
-   **减少重绘和重排**: 通过批量处理 DOM 更新，算法减少了浏览器的重绘和重排次数。

### 限制

-   **不同层级不交换**: Diff 算法通常不会将不同层级的节点交换位置，因为这会导致复杂的 DOM 操作。
-   **文本节点优化**: 对于文本节点，如果内容发生变化，Diff 算法通常会替换整个文本节点，而不是尝试局部更新。

### Vue 对 Diff 算法的优化

-   **动静结合与 Patch Flag**：在创建虚拟 DOM（vnode）时，会根据 vnode 内容是否可变化添加静态标记 Patch Flag。在 diff 过程中，只会比较有 Patch Flag 的节点，减少了不必要的对比。Patch Flag 有多种枚举值，例如 TEXT 表示可变化文本节点，还有动态 class、动态 style、动态属性、动态 key 属性等。这样在 diff 时只需比对相应类型的变化，比如对于标记为 TEXT 的节点，只需比对文本内容，提高了 diff 效率。
-   **静态提升（hoistStatic）**：在 Vue2 中，无论元素是否参与更新，每次触发更新都会重新创建所有 vnode。而 Vue3 对于不参与更新的 vnode，会做静态提升，只创建一次并保存其引用，在后续的 re-render 时直接复用，避免了重复创建的开销。
-   **事件侦听缓存（cacheHandlers）**：在 Vue2 中，`onClick`等事件会被视为动态绑定，每次 diff 时都要追踪其变化。而在 Vue3 中，如果事件是不会变化的，会将其缓存起来，该节点也不会被标记上 Patch Flag，从而在 render 和 diff 阶段都节约了不必要的性能消耗。
-   **使用最长递增子序列优化对比流程**：在 Vue2 的`updateChildren`函数中对比变更，而 Vue3 主要在`patchKeyedChildren`函数里进行。例如对于新旧 children 数组（如老的 children：`(a, b, c, d, e, f, g)`，新的 children：`(a, b, f, c, d, e, h, g)`），会先进行头和头比、尾和尾比，得到部分相同节点；再保存未比较过的节点，并通过映射获取它们在数组中的下标，生成新数组；然后取出新数组中的最长递增子序列，最后只需将其他剩余节点基于该子序列的位置进行移动、添加或删除操作，而不是像 Vue2 中进行多种可能的比较，提高了对比效率。

## Vue 异步更新队列

为了提高性能，Vue 不会立即对状态变化做出响应。相反，它将状态更新推迟到下一个事件循环中。

-   当状态变化被检测到时，Vue 会将更新任务放入一个异步队列中。这个队列管理着所有待处理的更新任务。
-   Vue 会批量处理队列中的更新任务，这意味着它会等待同一事件循环中的所有数据变化完成，然后一次性地应用到 DOM 上，从而避免不必要的重复渲染。
-   异步更新队列在事件循环的当前阶段结束时清空。这意味着在执行栈清空并且所有微任务完成后，Vue 会处理更新队列。

Vue 会将状态变化放到一个异步队列中，等待其他所有微任务完成后 Vue 开始处理更新队列

在 Vue 中，当数据发生变化时，Vue 并不是立即更新 DOM，而是将更新操作放入一个异步更新队列中。在同一事件循环周期内，所有的数据变化会被收集到这个队列中，然后在下一个事件循环的“tick”中统一进行 DOM 的更新。

## 虚拟 DOM 转化成真实 DOM、nextTick、UI 渲染之间的关系

### 步骤流程

1. 状态变化检测： 当 Vue 组件的状态（响应式数据）发生变化时，Vue 的响应式系统会立即检测到这些变化。
2. 放入异步队列： 一旦检测到状态变化，Vue 将更新操作放入一个异步队列中，而不是立即执行 DOM 更新。
3. 事件循环和微任务处理： JavaScript 运行时的事件循环会处理执行栈中的同步任务，然后处理微任务队列中的所有微任务。
4. Vue 处理异步队列： 在当前执行栈清空以及所有微任务完成后，Vue 开始处理异步队列中的更新。这是在事件循环的当前阶段结束时发生的。
5. 批量和去重（Diff）： Vue 可能会在单个事件循环中批量处理多个状态更新，以避免不必要的重复渲染。如果有多个状态变化，Vue 会尝试合并它们，只执行一次 DOM 更新。
6. 虚拟 DOM 重新渲染： Vue 使用虚拟 DOM 来计算状态变化对 DOM 的影响，并更新虚拟 DOM 树。然后，它会将这些变化应用到真实 DOM 上。
7. nextTick 机制：Vue 提供了 nextTick 函数，允许开发者延迟回调执行直到 DOM 更新完成后。在 Vue 3 中，nextTick 的回调是在微任务队列中注册的，因此它们会在 DOM 更新之后立即执行。
8. 浏览器渲染（回流重绘）： 一旦 Vue 完成 DOM 的更新，浏览器的渲染引擎可能会根据需要进行渲染，这通常发生在 Vue 处理完异步队列之后。

> 以上步骤除了浏览器渲染，通常是在一个事件循环里面实现的。UI 渲染可能是后面单独的一个事件循环，也可能是当前事件循环中进行渲染。浏览器渲染引擎会根据 JavaScript 的执行和 DOM 的变化，在合适的时机进行渲染更新

> **Vue 的异步更新队列与微任务的区别：**
>
> 尽管 Vue 3 使用 queueMicrotask() 来调度 nextTick 的回调，这看起来像是在微任务队列中添加任务，但实际上，Vue 的异步队列处理是在所有微任务都处理完毕后进行的。Vue 通过利用 JavaScript 事件循环的机制，确保异步更新队列在当前阶段的所有微任务处理完毕后执行，而不需要担心在当前阶段结束之后添加的微任务

### 官方文档

https://v2.cn.vuejs.org/v2/guide/reactivity.html#异步更新队列

**Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。**这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。

例如，当你设置 vm.someData = 'new value'，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。

> **事件循环“tick”**
>
> 文档中提到的“下一个事件循环‘tick’”，指的是在当前 JavaScript 执行栈清空并且所有微任务完成后，事件循环将进入下一个阶段。在这个新阶段，Vue 会刷新队列并执行实际的 DOM 更新工作。
>
> “tick”在这里可以理解为事件循环中的一个执行点，Vue 在这个点处理异步更新队列并执行 DOM 更新。
>
> 是指的一个事件循环中的不同阶段，而不是不同事件循环。
