# 浏览器渲染流程

主要步骤（加粗部分为主要步骤）

-   解析
    -   **1. 构建 DOM 树**
    -   预加载扫描器
    -   **2. 构建 CSSOM 树**
    -   其他过程
        -   JavaScript 编译
        -   构建无障碍树
-   渲染
    -   **3. 样式：将 DOM 和 CSSOM 组合成渲染树**
    -   **4. 布局（Layout）**
    -   **5. 绘制（Paint）**
    -   **6. 合成（Composition）**
-   交互

## 解析

### 构建 DOM 树

浏览器将 HTML 代码解析为 DOM 节点

#### DOM 树

-   DOM 树描述了文档的内容。
-   `<html>` 元素是第一个标签也是文档树的根节点。
-   树反映了不同标记之间的关系和层次结构。
-   DOM 节点的数量越多，构建 DOM 树所需的时间就越长。

#### 阻塞资源与非阻塞资源

##### 非阻塞资源

下面这些不会阻塞 HTML 的解析或下载，文件下载是异步的

-   CSS 文件加载
-   图片加载
-   带 async、defer 的 js 加载

##### 阻塞资源

-   不带 async、defer 的 js 阻塞 HTML 的下载和解析
    -   一旦 js 加载完后会立即执行，此时 HTML 可能还没解析完，如果进行 DOM 操作会失败
    -   写在 html 里面的`<script>`也会立即执行
-   CSSOM 构建的时候会阻塞 js 的执行
    -   如果 CSSOM 没有构建完，js 将无法使用 `getComputedStyle()` 等 API，对样式的操作会失败

##### async 和 defer

**共同点：** 都是异步加载，不会阻塞资源

**不同点：** defer 会按照出现的顺序执行，是有序的；async 加载完后会立即执行，是无序的。

### 预加载扫描器

-   **独立工作：** 预加载扫描器独立于 HTML 解析器工作，不影响 HTML 解析，但两者存在协作关系
-   **提前发现资源链接：** 预加载扫描器会在 HTML 解析到链接引用位置前，提前加载资源（如 css、js、图片等）
-   **关键资源优先：** 预加载扫描器通常优先加载对页面渲染和交互性能有重要影响的资源，例如 CSS 文件和 JavaScript 文件
-   **后台加载：** 构建 DOM 树占据主线程，预加载扫描器在后台加载

### 构建 CSSOM 树

-   CSS 对象模型和 DOM 是相似的
-   DOM 和 CSSOM 是两棵树。它们是独立的数据结构
-   与 HTML 类似，浏览器需要将接收到的 CSS 规则转换为可处理的格式。因此，它重复了 HTML 到对象的过程，但这次是针对 CSS。
-   构建 CSSOM 非常快，并且在当前的开发工具中没有以独特的颜色显示

### 其他过程

#### Javascript 编译

-   在解析 CSS 和创建 CSSOM 的同时，包括 JavaScript 文件在内的其他资源也在下载（因为预加载扫描器）
-   JavaScript 会被解析、编译和解释。脚本被解析为抽象语法树。有些浏览器引擎会将抽象语法树输入编译器，输出字节码。这就是所谓的 JavaScript 编译
-   大部分代码都是在主线程上解释的，但也有例外，例如在 web worker 中运行的代码。

#### 构建无障碍树

浏览器还构建辅助设备用于分析和解释内容的无障碍树。无障碍对象模型（AOM）类似于 DOM 的语义版本。当 DOM 更新时，浏览器会更新辅助功能树。辅助技术本身无法修改无障碍树。

## 渲染

### 样式

将 DOM 和 CSSOM 组合成**渲染树**

### 布局

渲染树构建完毕后，浏览器就开始**布局**，在渲染树上运行布局以计算每个节点的几何体。

-   **布局**是确定呈现树中所有节点的尺寸和位置，以及确定页面上每个对象的大小和位置的过程
-   **重排**（回流）是后续过程中对页面的任意部分或整个文档的大小和位置的重新计算

> 第一次确定每个节点的大小和位置称为**布局**。随后对节点大小和位置的重新计算称为**重排（回流）**

### 绘制

将各个节点绘制到屏幕上，其中第一次的绘制被称为首次有意义的绘制。

为了确保重绘能够比初始绘制更快地完成，绘制到屏幕的操作通常被分解成几个图层。如果发生这种情况，浏览器则需要进行合成。

### 合成

当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。

当页面继续加载资源时，可能会发生**回流**（回想一下我们迟到的示例图像），回流会触发**重新绘制**和**重新合成**。

-   如果我们定义了**图像的大小**，就不需要重新绘制，只需要绘制需要重新绘制的层，并在必要时进行合成
-   但我们并**没有定义图像大小**！所以从服务器获取图像后，渲染过程将返回到布局步骤并从那里重新开始。

> 因此图像要设置大小，避免重排
>
> CLS 产生了位置偏移，导致重排

## 交互

一旦主线程绘制页面完成，你会认为我们已经“准备好了”，但事实并非如此。如果加载包括正确延迟加载的 JavaScript，并且仅在 onload 事件触发后执行，那么主线程可能会忙于执行脚本，无法用于滚动、触摸和其他交互操作。
