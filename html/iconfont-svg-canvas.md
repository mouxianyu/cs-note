# Iconfont、SVG、Canvas

## Iconfont vs SVG

### SVG

-   **本质：** SVG 是基于 XML 的矢量图形，每个图形元素都是独立的，可以被编辑操作，HTML 中可以使用 JS 进行操作
-   **大小：** 文件相对较大，尤其是包含复杂图形的时候
-   **颜色：** 支持多种颜色，同时每个部分的颜色都可以进行修改
-   **兼容性：** 在现代浏览器中有较好的兼容性
-   **使用方式：** 可以直接嵌入 HTML 中，也可以当成图像引用
-   **资源消耗：** SVG 需要浏览器解析 XML 结构，可能在渲染复杂图形时消耗更多资源

### Iconfont

-   **本质：** Iconfont 是将图形制作成字体，通过字符来表示图标。可以通过字体相关样式来控制，如颜色、字体大小、阴影等 CSS 属性
-   **大小：** 文件大小相对比较少
-   **缓存：** 字体文件可以被浏览器缓存
-   **颜色：** 只能修改成单一的颜色，或者渐变色
-   **兼容：** 也有较好的兼容性，但在一些老旧设备或浏览器上可能会出现问题（因此通常要在字体部分加上一个 svg 格式文件的字体）

### SVG Symbol

-   使用 symbol 元素可以定义一个模板，模板包含路径、形状、文本等 svg 元素。通过<use>元素多次使用
-   symbol 定义的图形可以通过 JavaScript 进行动态操作，如改变属性、样式或行为。
-   减少 svg 文件大小
-   symbol 相当于一个模板，每次 use 都需要单独渲染

## Canvas vs SVG

### Canvas

-   **图形本质：** 是位图，用像素点来表示，缩放会像素化
-   **渲染：** 整个画布渲染
-   **交互：** 可以通过 JS 交互，但是不支持 CSS 交互
-   **SEO：** 作为图像渲染，不利于 SEO
-   **大小：** 通常文件较小，因为它不存储图形数据，而是在运行时动态绘制。
-   **性能：** 绘制复杂图形时性能较好，适合动态图形。
-   **场景：** 游戏、动画等需要实时绘制的场景。
-   WebGL 通常是在<canvas>元素上实现的

### SVG

-   **图形本质：** SVG 是矢量图，用 XML 表示，可以无损缩放
-   **渲染：** 可以对单独的标签渲染
-   **交互：** 支持 CSS 和 DOM 操作，可以很容易地添加样式和交互。
-   **SEO：** 基于 XML，有文本节点，利于 SEO
-   **大小：** 文件可能较大，因为它包含了完整的图形描述。
-   **性能：** 在文档大小增加时性能可能会受影响，不适合复杂的动态图形。
-   **场景：** 图标、图表等需要保持清晰度的场景。
