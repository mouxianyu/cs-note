# 进程与线程

-   **程序（Program）：**
    -   是为完成特定任务、用某种语言编写的一组指令的集合。
    -   它是**静态**的**代码和相关数据**的集合。
-   **进程（Process）：**
    -   进程是程序执行的实例（可以有多承实例），是程序在执行时的动态载体。
    -   每个进程都有自己独立的内存空间，包括代码段、数据段和堆栈。不同进程的空间互不干扰，单操作系统会提供相应的机制来共享资源。
    -   进程是资源分配的基本单位，操作系统为每个进程分配资源并管理执行。
-   **线程（Thread）：**
    -   线程是进程中的一个执行单元，是 CPU 调度和执行的单位
    -   一个进程可以包含多个线程，这些线程共享进程的资源，如内存空间和文件句柄
    -   线程比进程更轻量级，创建和切换的开销很小
    -   线程可以并发执行，提高程序的执行效率

> 简单说：程序是可以被执行的代码和数据，进程是程序执行的一个实例，操作系统分配给每个进程单独的资源（资源隔离，但是可以通过操作系统提供的机制共享），每个进程的资源，被进程包含的多个线程共享。进程是资源分配的最小单位，线程是执行的最小单位。

## 浏览器是多进程

浏览器是多进程的，每一个 tab 标签都是一个进程。进程中包含 UI 渲染线程、js 引擎线程、http 请求线程等。

## JS 是单线程

### JS 为什么设计成单线程

-   单线程使得语言模型相对简单，便于理解和开发
-   浏览器中需要与 DOM 等进行交互，单线称可以避免复杂的问题（如多个线程同时操作 DOM）
-   早期的 Web 开发需求相对简单，单线程能够满足需求

## 堆（Heap）和栈（Stack）

### 堆

**动态分配** ：用于动态地分配内存，程序可以在运行时根据需要申请或释放内存空间。
**较大空间** ：相对栈来说，堆可以提供更大的内存空间。
**分配和释放操作** ：需要程序员手动管理内存的分配和释放，容易出现内存泄漏等问题。

### 栈

**自动管理** ：由系统自动管理，遵循先进后出的原则。
**存储局部变量** ：用于存储函数调用时的局部变量、函数参数等。
**空间有限** ：栈的空间相对较小，且大小是固定的。

## 进程线程与堆栈的分配

-   一个进程只有一个堆，至少有一个栈
-   每个线程都有自己独立的栈，但是他们共享堆（线程共享进程的堆）

### 进程：

-   **堆** ：
    -   一个进程通常只有一个堆，用于动态内存分配。
    -   堆是一块可以在运行时请求和释放内存的区域。
    -   进程中的所有线程共享这个堆。
-   **栈** ：
    -   每个进程至少有一个栈，用于存储局部变量、函数参数、返回地址等。
    -   每个线程都有自己的栈，以支持独立的函数调用序列。

### 线程：

-   **堆** ：线程不单独拥有堆，它们共享所属进程的堆内存。
-   **栈** ：每个线程都有自己的栈，用于存储线程特定的局部变量和调用栈。

### 为什么每个线程都有自己的栈

-   **线程执行独立性**：每个线程在执行时都需要有自己独立的空间来存储局部变量、函数调用信息等，以保证线程之间的执行互不干扰。
-   **上下文切换**：当线程进行上下文切换时，栈上的信息可以完整地保存和恢复，确保线程切换前后的状态一致性。
-   **函数调用和返回**：线程需要独立的栈来管理各自的函数调用和返回操作，避免相互影响。
-   **异常处理**：当线程中的代码抛出异常时，异常处理逻辑可以仅针对该线程的栈进行，而不会影响到其他线程的执行。

## 浏览器的进程与线程

### 主要进程

1. **Browser 进程**：浏览器的主进程（负责协调、主控），只有一个
    - 负责浏览器界面显示，与用户交互。如前进，后退等
    - 负责各个页面的管理，创建和销毁其他进程
    - 将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上
    - 网络资源的管理，下载等
2. **第三方插件进程**：每种类型的插件对应一个进程，仅当使用该插件时才创建
3. **GPU 进程**：最多一个，用于 3D 绘制等
4. **浏览器渲染进程**（浏览器内核）（Renderer 进程，内部是多线程的）
    - 默认每个 Tab 页面一个进程，互不影响
    - 主要用于页面渲染，**脚本执行**，事件处理等

### 主要线程

1. **UI 渲染线程**
    - 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
    - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
    - 注意，**GUI 渲染线程与 JS 引擎线程是互斥的**，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行
2. **JS 引擎线程**
    - 也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）
    - JS 引擎线程负责解析 Javascript 脚本，运行代码。
    - JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序
    - 同样注意，**GUI 渲染线程与 JS 引擎线程是互斥的**，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞
3. **事件触发线程**
    - 归属于浏览器而不是 JS 引擎，用来**控制事件循环**（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）
    - 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中
    - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
    - 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）
4. **定时触发器线程**
    - 传说中的 `setInterval` 与 `setTimeout` 所在线程
    - 浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
    - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
    - 注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。
5. **异步 http 请求线程**
    - 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
    - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。
6. **web workers 线程**
    - JavaScript 也可以在 Web Workers 中执行，这是一种在后台线程上运行脚本的方式，不干扰主线程。
    - Web Workers 允许执行长时间运行的任务，如数据处理或计算密集型任务，而不会阻塞 UI。

> JS 执行在**浏览器渲染进程**、**JS 引擎线程**、**Web Workers 线程**
