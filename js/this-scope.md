# this 作用域

-   `this` 的值取决于它出现的上下文：函数、类或全局

## 严格模式和非严格模式

-   在非严格模式下， `this` 总是指向一个对象，在严格模式下可以是任意值
-   在非严格模式下，如果 `this` 不是一个对象的话，会被替换成对象
    -   如果一个函数被调用时 `this` 被设置为 `undefined` 或 `null`， `this` 会被替换为 `globalThis`
    -   如果函数被调用时 `this` 被设置为一个原始值，`this` 会被替换为原始值的包装对象

> ES Module 转化成 ES5 使用了严格模式， 因此在 ES Module 中 this 指向 undefined

## 全局上下文

全局直接打印，严格模式下 this 是 undefined，非严格模式下 this 会被替换成 globalThis（浏览器是 window，Node.js 是 global）

```js
// window
console.log(this)
```

```js
// 严格模式
// undefined
console.log(this)
```

## 类上下文

类上下文中 this 指向类本身

```js
class Dog {
    static SELF = this
}
console.log(Dog.SELF === Dog)
```

## 函数上下文

**普通函数**： 函数内部 this 的值取决于函数如何被调用。
**箭头函数**： 箭头函数不提供自身的 this 绑定（this 的值将保持为**闭合词法上下文**的值，即箭头函数能够记住其创建时**词法作用**域中的 this 值）。

-   直接调用函数：指向 undefined/全局上下文
-   构造函数：指向新创建的实例
-   对象调用函数：指向对象
-   回调函数：取决于调用方式
    -   事件处理函数：在 DOM 事件处理中，事件处理函数的 this 通常指向触发事件的 DOM 元素。
    -   定时器回调函数：如 setTimeout、setInterval 的回调函数，this 可能指向全局对象(直接调用严格模式下也是全局对象)或特定的上下文（具体取决于调用方式）
    -   promise 的 then、catch、finally：指向 undefined

## 词法作用域

词法作用域是指变量的作用范围由其在代码中的位置（即词法结构）所决定。

要点：

-   **在定义时确定**：变量的作用域在其定义的位置就已经确定，而不是在运行时动态改变。
-   **嵌套结构**：内层作用域可以访问外层作用域的变量，但外层作用域不能访问内层作用域的变量。
-   **与函数调用无关**：作用域的划分与函数如何被调用无关，只与函数定义的位置有关

### 常见词法作用域

JavaScript 中的词法作用域主要包括以下几种：

1. **全局作用域**：在任何函数外部声明的变量，它们在整个脚本范围内都可访问。
2. **函数作用域**：在函数内部声明的变量，它们只能在该函数及其嵌套函数内部访问。
3. **块级作用域**：使用 `let` 和 `const` 在代码块（如 `{}` 内）声明的变量，它们只在该代码块及其嵌套的子块内部可访问。
4. **类作用域**：在类内部声明的静态变量和方法，它们属于类的静态作用域。
5. **模块作用域**：在 ES6 模块中，每个模块都有自己的作用域，模块内部的变量和函数默认是私有的。
6. **词法环境作用域**：JavaScript 引擎内部使用词法环境来实现作用域链，每个词法环境可以访问其外部词法环境。

> **对象**的花括号不算词法作用域，**类**的花括号是词法作用域，因为类在 **ES5** 中也算是一种特殊的函数
>
> 因此如果类的函数属性是箭头函数的话，箭头函数的 this 指的是 class 本身，而对象方法如果是箭头函数的话，指的是对象外层作用域的 this
