# 闭包

## 例子

```javascript
function createClosure() {
    var secret = "I'm a secret!"
    return function () {
        console.log(secret)
    }
}

var myClosure = createClosure()
myClosure() // 输出: "I'm a secret!"
```

在这个例子中，`createClosure` 函数返回了一个匿名函数，这个匿名函数可以访问 `createClosure` 函数内的局部变量 `secret`。即使 `createClosure` 函数执行完毕后，返回的闭包仍然可以访问 `secret`，因为它形成了一个封闭的作用域。

## 概念

### 定义

-   闭包指的是一个函数能够**记住并访问其创建时所在的作用域**，即使这个函数在其原始作用域之外被执行。
-   简单来说，闭包允许一个函数**访问创建时的环境**，即使它被移动到另一个作用域中。

> 函数能够访问到其创建时所在的作用域，即使函数是在其原始作用域外执行的

## 常见的产生闭包的方式

1. **函数作为返回值** ： 函数返回另一个函数，返回的函数可以访问外部函数的局部变量。
2. **函数作为参数传递** ：将一个函数作为参数传递给另一个函数，作为参数的函数可以访问外部函数的局部变量。
    - setTimeout、setInterval、事件监听器、Promise 以及大都数有用到外部函数的局部变量的回调函数都是这种形式
3. **对象、类、原型的方法** ： 方法可以访问内部属性

## 闭包在真实业务场景的使用

1. **缓存数据** ： 利用闭包保存计算结果或缓存数据，避免重复计算。
2. **异步编程** ： 比如 Promise 这些；XMLHttpRequest 请求可以使用回调函数，处理请求结果
3. **事件处理** ：在事件处理中，闭包可以方便地访问相关的事件对象和上下文信息。
4. **函数工厂** ：使用闭包创建函数工厂，根据不同的输入生成具有不同行为的函数。
5. **状态管理** ：在复杂的应用中，闭包可以用于封装状态，避免全局变量的使用。
6. **节流防抖** ：在防抖和节流的实现过程中，需要保存一些状态信息（如定时器、上一次执行的时间等），这些状态信息可以通过闭包来访问和维护，从而实现相应的功能。

## 闭包的缺点

1. **内存占用** ：由于闭包会保留对外部作用域变量的引用，可能导致这些变量不会被及时释放，从而增加内存占用。
2. **循环引用** ：在某些情况下，可能会形成循环引用，导致内存泄漏。

## 如何避免闭包产生的内存泄露

1. **及时清理** ：在不再需要闭包时，手动将相关的变量设置为 null 或重新赋值，以解除对外部变量的引用。
2. **合理设计** ：
    1. 不需要闭包的特性就不使用闭包
    2. 尽量减少闭包对外部变量的使用
3. **使用弱引用** ：在某些情况下，可以使用 WeakMap 或 WeakSet 来存储闭包的引用。这些数据结构的键是弱引用，当键不再被其他地方引用时，可以被垃圾收集器回收。
4. **使用内存分析工具** ：使用内存分析工具来检测内存泄漏，如 Chrome 的 DevTools 中的 Memory 面板。

## 内存泄漏的其他常见原因

1. **循环引用** ：对象之间形成循环引用时，即使不涉及闭包，也会导致内存泄漏。
2. **未释放的事件监听器** ：如果元素上绑定了事件监听器，但在不需要它们时未手动移除，可能会导致内存泄漏。
3. **未清理的定时器** ：未清除的定时器会一直持有对函数的引用，导致相关对象无法被垃圾回收。
