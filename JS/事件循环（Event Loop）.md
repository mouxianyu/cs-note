## 定义
事件循环（Event Loop）是JavaScript运行时的一个核心概念，它允许JavaScript引擎在单线程环境中执行异步操作。

## JS是单线程语言
JavaScript 是一种单线程语言，这意味着它一次只能执行一个任务。然而，JavaScript 能够处理异步操作，比如网络请求、定时事件等，而不会导致程序挂起。这得益于 JavaScript 的事件循环机制。

## 事件循环
事件循环是 JavaScript 运行时（如浏览器或 Node.js）用来处理任务队列的一种机制。它允许 JavaScript 引擎在执行同步代码的同时，处理异步任务。

事件循环的机制使得 JavaScript 能够以**非阻塞的方式处理大量任务**，包括**同步和异步任务**。这种机制是 JavaScript 能够实现**高性能和高响应性**的关键因素之一。

## 基本概念
### 执行栈（Call Stack）
这是 JavaScript 执行代码的地方。当 JavaScript 执行代码时，所有同步任务都会添加到这个栈中。
### 事件队列（Event Queue）
当异步任务完成时，它们会被放入一个或多个事件队列中。每个队列可能代表不同类型的事件，比如网络请求、定时器、用户交互等。

**事件队列分为宏任务队列（Macro Task Queue）和微任务队列（Micro Task Queue）**
**微任务优先级比宏任务高，微任务先执行**
#### 宏任务队列（Macro Task Queue）
宏任务队列包含了一些**需要较长时间执行**的任务，它们通常不会立即执行，而是在当前执行栈清空后按顺序执行。
常见的**宏任务**包括：
- `setTimeout` 和 `setInterval` 定时器
- `requestAnimationFrame` 用于动画和页面渲染
- I/O 操作，比如从网络读取数据或写入数据到文件
- 页面的重新渲染（尽管这通常不直接由 JavaScript 控制）
#### 微任务队列（Micro Task Queue）
微任务队列包含了一些**需要尽快执行**的任务，它们会在当前执行栈清空以及当前宏任务完成后立即执行。
常见的**微任务**包括：
- Promise 回调，包括 `.then()`, `.catch()`, 和 `.finally()`
- `MutationObserver` 回调，用于监听 DOM 变动
- `queueMicrotask()` API，可以用来延迟执行一些小的、非阻塞的任务
### 事件循环（Event Loop）
这是 JavaScript 引擎的一部分，负责检查执行栈是否为空。如果栈为空，事件循环会从事件队列中取出第一个任务，放入执行栈中执行。

## 事件循环过程
同步任务-->微任务-->宏任务-->渲染更新
### 1. 开始执行
当 JavaScript 引擎开始执行代码时，所有同步任务都会被放入执行栈（Call Stack）中按顺序执行。
### 2. 检查执行栈
事件循环检查执行栈是否为空。如果执行栈不为空，继续执行栈中的同步任务。
### 3. 执行栈清空
当执行栈中的所有同步任务执行完毕后，执行栈清空。
### 4. 检查微任务队列
一旦执行栈清空，事件循环会检查微任务队列（Micro Task Queue）。微任务包括 Promise 的回调、MutationObserver 回调等。事件循环会按照它们被添加的顺序，依次执行所有微任务。
### 5. 执行微任务
事件循环从微任务队列中取出所有任务，并将它们放入执行栈中执行。这个过程会一直持续，直到微任务队列为空。
### 6. 检查宏任务队列
微任务队列清空后，事件循环会检查宏任务队列（Macro Task Queue）。宏任务包括 setTimeout、setInterval、requestAnimationFrame、I/O 操作、UI 渲染等。
### 7. 执行一个宏任务
事件循环从宏任务队列中取出第一个任务，将其放入执行栈中执行。这会导致执行栈再次被填充，并且可能再次触发微任务的执行。
### 8. 回到步骤2
执行完当前宏任务后，事件循环回到步骤2，再次检查执行栈是否为空，然后继续执行微任务和宏任务。
### 9. 渲染更新
在某些情况下，如浏览器环境中，UI 渲染可能会在宏任务执行后进行，以确保用户界面的更新。
### 10. 重复循环
事件循环会不断重复这个过程，直到执行栈和所有事件队列都为空。

## 为什么微任务优先级高于宏任务
1. **快速响应**: 微任务通常代表了一些需要尽快执行的操作，比如 Promise 的回调。这些操作通常与用户的交互或程序的状态更新紧密相关。优先执行微任务可以确保这些操作能够迅速得到处理，从而提高应用程序的响应性。
2. **避免长时间阻塞**: 宏任务（如 `setTimeout` 或 I/O 操作）可能需要较长时间来完成。如果宏任务优先执行，那么在它们执行期间，微任务队列中的回调将被阻塞，这可能导致应用程序的界面或状态更新被延迟。
3. **防止饥饿**: 如果宏任务连续不断地添加到队列中，而微任务总是被推迟执行，这可能导致微任务队列中的回调长时间得不到执行，这种现象称为“饥饿”。优先执行微任务可以避免这种情况。
4. **保持事件的顺序**: 在某些情况下，微任务的执行依赖于宏任务的结果。例如，一个异步请求可能在完成时返回一个值，该值随后被用在一个 Promise 的 `.then()` 回调中。如果宏任务（异步请求）和微任务（`.then()` 回调）能够连续执行，这可以保持事件处理的顺序性和逻辑性。
5. **优化性能**: 微任务通常执行时间较短，将它们优先处理可以减少等待时间，提高程序的整体性能。
6. **符合预期**: 开发者可能期望某些异步操作能够尽快完成。例如，在一个异步操作完成后立即进行状态更新或数据验证。微任务的优先级确保了这些操作能够在下一个宏任务开始之前完成。

