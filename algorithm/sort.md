# 排序算法

| 排序算法 | 时间复杂度                    | 空间复杂度 | 稳定性 | 主要思想                                                   |
| -------- | ----------------------------- | ---------- | ------ | ---------------------------------------------------------- |
| 冒泡排序 | O(n^2)                        | O(1)       | 稳定   | 相邻元素比较，交换位置，重复遍历数组，直到排序完成         |
| 选择排序 | O(n^2)                        | O(1)       | 不稳定 | 遍历未排序序列，找到最小（或最大）值，放到已排序序列的末尾 |
| 插入排序 | O(n^2)                        | O(1)       | 稳定   | 从后向前扫描，将新元素插入到已排序序列的适当位置           |
| 希尔排序 | 取决于增量序列，平均 O(nlogn) | O(1)       | 不稳定 | 将数组分成多个子序列，各自进行插入排序，逐步减少增量       |
| 归并排序 | O(nlogn)                      | O(n)       | 稳定   | 分治法，将数组分成两半，递归排序后再合并                   |
| 快速排序 | O(nlogn)                      | O(logn)    | 不稳定 | 选择基准值，分区操作，递归地对子序列进行快速排序           |
| 堆排序   | O(nlogn)                      | O(1)       | 不稳定 | 构建最大堆或最小堆，将堆顶元素与末尾元素交换，调整堆       |
| 计数排序 | O(n+k)，k 是整数范围          | O(k)       | 稳定   | 非基于比较的排序，使用额外数组来记录整数出现的次数         |
| 桶排序   | 最优 O(n+k)，k 是桶的数量     | O(n+k)     | 稳定   | 分配数组元素到各个桶中，对每个桶进行排序，然后合并         |
| 基数排序 | O(nk)，k 是最大数位数         | O(n+k)     | 稳定   | 按照低位先排序，然后收集，再按高位排序，依次类推           |

> 稳定性： 衡量一个排序算法是否稳定，主要是看在排序过程中，相等元素的相对顺序是否被保持。具体来说，如果两个元素在原始数组中具有相同的值，并且在一个元素出现在另一个之前，那么在排序后的数组中，先出现的元素应该仍然在后出现的元素之前。这种特性就是所谓的稳定性
